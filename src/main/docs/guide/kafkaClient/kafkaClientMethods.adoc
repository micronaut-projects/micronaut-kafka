=== Specifying the Key and the Value

The Kafka key can be specified by providing a parameter annotated with `@KafkaKey`. If no such parameter is specified the record is sent with a `null` key.

The value to send is resolved by selecting the argument annotated with https://docs.micronaut.io/latest/api/io/micronaut/messaging/annotation/MessageBody.html[@MessageBody], otherwise the first argument with no specific binding annotation is used. For example:

[source,java]
----
@Topic("my-products")
void sendProduct(@KafkaKey String brand, String name);
----

The method above will use the parameter `brand` as the key and the parameter `name` as the value.

=== Including Message Headers

There are a number of ways you can include message headers. One way is to annotate an argument with the https://docs.micronaut.io/latest/api/io/micronaut/messaging/annotation/MessageHeader.html[@MessageHeader] annotation and include a value when calling the method:

[source,java]
----
@Topic("my-products")
void sendProduct(
    @KafkaKey String brand,
    String name,
    @MessageHeader("My-Header") String myHeader);
----

The example above will include the value of the `myHeader` argument as a header called `My-Header`.

Another way to include headers is at the type level with the values driven from configuration:

.Declaring @KafkaClient Headers
[source,java]
----
include::{testskafka}/producer/headers/ProductClient.java[tags=imports, indent=0]

include::{testskafka}/producer/headers/ProductClient.java[tags=clazz, indent=0]
    ...
}
----

The above example will send a header called `X-Token` with the value read from the setting `my.application.token` in `application.yml` (or the environment variable `MY_APPLICATION_TOKEN`).

If the `my.application.token` is not set then an error will occur creating the client.

It is also possible to pass `Collection<Header>` or `Headers` object as method arguments as seen below.

.Collection<Header> Argument
[source,java]
----
@Topic("my-bicycles")
void sendBicycle(
    @KafkaKey String brand,
    String model,
    Collection<Header> headers);
----

https://javadoc.io/doc/org.apache.kafka/kafka-clients/latest/org/apache/kafka/common/header/Header.html[Kafka Header Javadocs]

.Headers Argument
[source,java]
----
@Topic("my-bicycles")
void sendBicycle(
    @KafkaKey String brand,
    String model,
    Headers headers);
----

https://javadoc.io/doc/org.apache.kafka/kafka-clients/latest/org/apache/kafka/common/header/Headers.html[Kafka Headers Javadocs]

In the above examples, all of the key/value pairs in `headers` will be added to the list of headers produced to the topic.  `Header` and `Headers` are
part of the `kafka-clients` library:

=== Reactive and Non-Blocking Method Definitions

The ann:configuration.kafka.annotation.KafkaClient[] annotation supports the definition of reactive return types (e.g. rs:Publisher[]) as well as Futures.

The following sections cover possible method signatures and behaviour:

==== Single Value and Return Type

[source,java]
----
@SingleResult
Publisher<Book> sendBook(
    @KafkaKey String author,
    Publisher<Book> book
);
----

The implementation will return a rs:Publisher[] that when subscribed to will subscribe to the passed rs:Publisher[] and send the emitted item as a `ProducerRecord` emitting the item again if successful or an error otherwise.

NOTE: Micronaut uses the https://docs.micronaut.io/latest/api/io/micronaut/core/async/annotation/SingleResult.html[@SingleResult] annotation to indicate a single result is emitted for the rs:Publisher[] return type.

==== Publisher Value and Return Type

[source,java]
----
Publisher<Book> sendBooks(
    @KafkaKey String author,
    Publisher<Book> book
);
----

The implementation will return a rs:Publisher[] that when subscribed to will subscribe to the passed rs:Publisher[] and for each emitted item will send a `ProducerRecord` emitting the item again if successful or an error otherwise.

==== CompletableFuture Value and Return Type

[source,java]
----
CompletableFuture<RecordMetadata> sendBooks(
    @KafkaKey String author,
    CompletableFuture<Book> book
);
----

The implementation will return a `CompletableFuture` that when subscribed to will subscribe to the passed `CompletableFuture` and for each emitted item will send a `ProducerRecord` emitting the resulting Kafka `RecordMetadata` if successful or an error otherwise.

=== Available Annotations

There are a number of annotations available that allow you to specify how a method argument is treated.

The following table summarizes the annotations and their purpose, with an example:

.Kafka Messaging Annotations
|===
|Annotation |Description |Example

|https://docs.micronaut.io/latest/api/io/micronaut/messaging/annotation/MessageBody.html[@MessageBody]
| Allows explicitly indicating the body of the message to sent
|`@MessageBody Product product`

|https://docs.micronaut.io/latest/api/io/micronaut/messaging/annotation/MessageHeader.html[@MessageHeader]
| Allows specifying a parameter that should be sent as a header
|`@MessageHeader("X-My-Header") String myHeader`

|ann:configuration.kafka.annotation.KafkaKey[]
| Allows specifying the parameter that is the Kafka key
|`@KafkaKey String key`

|ann:configuration.kafka.annotation.KafkaPartition[]
| Allows specifying the parameter that is the partition number
|`@KafkaPartition Integer partition`

|ann:configuration.kafka.annotation.KafkaPartitionKey[]
| Allows specifying the parameter that is used to compute a partition number independently from the Message Key.
|`@KafkaPartition String partitionKey`

|===

For example, you can use the https://docs.micronaut.io/latest/api/io/micronaut/messaging/annotation/MessageHeader.html[@MessageHeader] annotation to bind a parameter value to a header in the `ProducerRecord`.
